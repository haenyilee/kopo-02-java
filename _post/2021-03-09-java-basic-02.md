# java 기초 (2)

## 유니코드
- 유니코드 65인 문자를 char 변수에 저장하려면 16진수 형태로 표현해야 한다.
- 2진수의 3비트씩 묶고 8진수, 4비트로 묶으면 16진수로 표현할 수 있다. 
- `ch = '\u0041'; // 유니코드 65인 문자를 ch에 저장 (16진수 형태로 표현)`

- 8진수와 16진수 중에서 개발자 입장에서는 속도를 빨리하기 위한 연산에서는 16진수를 사용한다. 
- 개발자입장에서 byte가 단위이기 때문에 1byte인 8bit를 4bit씩의 배수로 표현할 수 있는 16진수를 8진수보다 많이 사용하는 것이다. 

- char는 유니코드이니까 2byte이다. 2byte를 16진수로 표현하기 위해서는 4자리가 필요하다. (1byte는 16진수 2자리)
- ![image](https://user-images.githubusercontent.com/77392444/110401492-00787280-80bd-11eb-9d8d-8db1041b29b1.png)



## EUC-KR와 UTF-8차이
- EUC-KR : 유니코트 기반이라 한글 하나를 2byte로 해석한다. 
- UTF-8 : 한글 하나를 3byte로 인식한다. (초, 중, 종성)

## 형변환
- char의 정수값을 알고싶다면? 정수형 `int`로 형변환을 하면 된다. 

```java
char ch = 'A';
System.out.println((int)ch);
```

- 형변환이란 연산자를 기준으로 좌변과 우변안에 타입이 다른 경우 발생된다. (기본자료형의 형변환)
- 컴퓨터는 연산자를 기준으로 왼쪽과 오른쪽의 자료형이 같아야 연산할 수 있기 때문이다. 

- 자바에서는 객체 형변환도 가능하다. (참조형 형변환)

- 형변환의 종류에는 크게 (1) 묵시적 형변환, (2) 명시적 형변환 이 있다.

### 묵시적 형변환
- 묵시적 형변환은 자료형을 명시해주지 않아도 큰 type의 자료형을 따라 자동으로 연산되는 것을 의미한다. 
- 묵시적 형변환에 따라서 `'a' + 20`의 연산에서 a가 int형으로 인식되어 결과가 97이 된다. 
- 기본적으로 컴퓨터는 연산 시에는 큰 수의 type을 따르기 때문이다. 
- 묵시적 형변환이 발생한다면 형변환 자료형을 명시해주지 않아도 된다. 

### 명시적 형변환
- 명시적 형변환은 큰 data type을 작은 data type으로 변환해주는 것이다.
- 예시 : 

```java
System.out.println((int)12.3 + 45);
int num = (int)12.35;
```

## 연산자
- 컴퓨터에서는 단항과 이항연산자밖에 없다.
- 단항연산자는 하나만 가지고 연산하는 것이다. (`- , ! , 증감연산자` 등)
- 이항연산자는 두 수를 가지고 연산하는 연산자이다. 
- 컴퓨터는 왼쪽에서부터 오른쪽으로 이동하면서 두 개씩 연산한다.(참고 : 후위표현식/중위표현식)

- 증감연산자는 개발자가 코드를 더 단순화하기 위해 탄생한 단항연산자이다. 
- 증감연산자가 없다면, `num++`를 `num = num +1`라고 이항연산자로 작성해야 한다.
- `num++`과 `++num` 중에서는 `++num`이 더 빠르다.

```java
num = 20;
System.out.println(++num); // 21

num = 20;
System.out.println(num++); // 20 : System.out.println수행 후에 ++되기 때문이다.
```

- 복합대입연산자, 대항연산자 : 더한 다음에 변수에 대입하고 싶다면? `num+=3`

- 논리연산자에서 컴퓨터가 인식하는 방식이 앞의 것이 참인지/거짓인지에 달려있기 때문에 교환법칙이 성립하지 않는다. 
